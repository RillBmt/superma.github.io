<!DOCTYPE html>
<html lang="">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="x5-fullscreen" content="true">
<meta name="full-screen" content="yes">
<meta name="theme-color" content="#317EFB" />
<meta content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=0" name="viewport">
<meta name="keywords" content="ѧϰ�����ԣ�C++��Unreal����Ϸ����">
<meta name="description" content="C++基础入门：7 指针7.1 指针的基本概念指针的作用：可以通过指针间接访问内存  内存编号是从0开始的，一般用十六进制数字表示 可以利用指针变量保存地址  7.2 指针变量的定义和使用指针变量定义语法： 数据类型 * 变量名; 7.3 指针所占内存空间在32位操作系统下：占用4个字节空间，64位下占8个字节空间 7.4 空指针和野指针 空指针：指针变量指向内存中编号为0的空间 用图：初始化指针">
<meta property="og:type" content="article">
<meta property="og:title" content="C++笔记">
<meta property="og:url" content="https://rillma.github.io/2022/07/17/Cpp%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="SuperMa&#39;s Blog">
<meta property="og:description" content="C++基础入门：7 指针7.1 指针的基本概念指针的作用：可以通过指针间接访问内存  内存编号是从0开始的，一般用十六进制数字表示 可以利用指针变量保存地址  7.2 指针变量的定义和使用指针变量定义语法： 数据类型 * 变量名; 7.3 指针所占内存空间在32位操作系统下：占用4个字节空间，64位下占8个字节空间 7.4 空指针和野指针 空指针：指针变量指向内存中编号为0的空间 用图：初始化指针">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rillma.github.io/img/C++Note.jpeg">
<meta property="article:published_time" content="2022-07-17T14:26:55.000Z">
<meta property="article:modified_time" content="2022-08-14T13:32:42.219Z">
<meta property="article:author" content="SuperMa">
<meta property="article:tag" content="ѧϰ�����ԣ�C++��Unreal����Ϸ����">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rillma.github.io/img/C++Note.jpeg">

    <meta name="description" content="Everything deserves to be recorded">

<title>
    C++笔记
</title>

    <link rel="icon" type="image/png" sizes="16x16" href="/img/blacklogo16.jpg?v=1.0.2">


    <link rel="icon" type="image/png" sizes="32x32" href="/img/blacklogo32.jpg?v=1.0.2">



<link rel="preload" href="//at.alicdn.com/t/font_1518765_bkgx3wku6h4.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1518765_bkgx3wku6h4.css">


<link rel="stylesheet" href="/css/plugins/bootstrap.min.css">
<link rel="stylesheet" href="/css/plugins/locomotive-scroll.css">
<link rel="stylesheet" href="/css/plugins/swiper.min.css">
<link rel="stylesheet" href="/css/plugins/fancybox.min.css">
<link rel="stylesheet" href="/css/plugins/font-awesome.min.css">


<!-- variable -->
<script>window.TYPED_TEXT=[
  "Super Ma"
]</script>
<script>window.FAVICON={
  "icon16": "/img/blacklogo16.jpg",
  "icon32": "/img/blacklogo32.jpg",
  "appleTouchIcon": null,
  "webmanifest": null,
  "visibilitychange": true,
  "hidden": null,
  "showText": "(/≧▽≦/)哇！你又来了！",
  "hideText": "(●—●)喂，你咋走了？"
}</script>
<script>window.HTMEM_VERSION='1.0.2'</script>
<link data-theme-type="style-light" rel="stylesheet" href="/css/style-light.css?v=1.0.2" id="trm-switch-style">
<link data-theme-type="style-dark" rel="stylesheet" href="/css/style-dark.css?v=1.0.2" id="trm-switch-style">

<!-- theme css -->
<script>
    let themeMode = localStorage.getItem('theme-mode') === 'style-dark' ? 'style-light' : 'style-dark';
    let linkdom = document.querySelector('[data-theme-type='+themeMode+']');
    if(linkdom) linkdom.remove();
</script>

<!-- Site Analytics -->
 
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="SuperMa's Blog" type="application/atom+xml">
</head>

<body>

  <!-- app wrapper -->
  <div class="trm-app-frame">

    <!-- page preloader -->
    <div class="trm-preloader">
    <div class="trm-holder">
        <div class="preloader">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
</div>
    <!-- page preloader end -->

    <!-- change mode preloader -->
    <div class="trm-mode-swich-animation-frame">
    <div class="trm-mode-swich-animation"><i class="far fa-sun"></i>
        <div class="trm-horizon"></div>
        <i class="far fa-moon"></i>
    </div>
</div>
    <!-- change mode preloader end -->

      <!-- scroll container -->
      <div id="trm-dynamic-content" class="trm-swup-animation">
        <div id="trm-scroll-container" class="trm-scroll-container" data-scroll-container style="opacity: 0">
          <div data-scroll-section id="content" class="trm-scroll-section">
            <!-- top bar -->
            <div class="trm-top-bar" data-scroll data-scroll-sticky data-scroll-target="#content" data-scroll-offset="-10">
	<div class="container">
		<div class="trm-left-side">
			<!-- logo -->
			<a href="/" class="trm-logo-frame trm-anima-link">
				<img src="/img/blacklogo32.jpg" alt="logo">
				<div class="trm-logo-text">
					Super
					<span>Ma</span>
				</div>
			</a>
			<!-- logo end -->
		</div>
		<div class="trm-right-side">

			<!-- menu -->
			<div class="trm-menu">
				<nav>
					<ul>
						
						<li class="menu-item-has-children ">
							<a  href="/">
								首页
							</a>
							
						</li>
						
						<li class="menu-item-has-children ">
							<a  href="/archives/">
								归档
							</a>
							
						</li>
						
						<li class="menu-item-has-children ">
							<a  href="/links/">
								友链
							</a>
							
						</li>
						
						<li class="menu-item-has-children ">
							<a  href="/about/">
								关于
							</a>
							
						</li>
						
					</ul>
				</nav>
			</div>
			<!-- menu end -->

			<!-- mode switcher place -->
			<div class="trm-mode-switcher-place"></div>
			<!-- mode switcher place end -->

		</div>
		<div class="trm-menu-btn">
			<span></span>
		</div>
	</div>
</div>
            <!-- top bar end -->

            <!-- body -->
            <div class="trm-content-start">

    <!-- banner -->
    <div class="trm-banner" data-scroll data-scroll-direction="vertical">
    <!-- banner cover -->
    <img src="/img/tzz1.jpg" alt="banner" class="trm-banner-cover" data-scroll data-scroll-direction="vertical" data-scroll-speed="-3">
    <!-- banner cover end -->

    <!-- banner slideshow cover-->
    <!-- <div class="swiper-container trm-slideshow" data-scroll data-scroll-direction="vertical" data-scroll-speed="-4">
        <div class="swiper-wrapper">
            <div class="swiper-slide"><img src="/img/blog/b1.jpg" alt="banner" class="trm-banner-cover" data-swiper-parallax-y="-200" data-swiper-parallax-scale="1.2"></div>
            <div class="swiper-slide"><img src="/img/blog/b2.jpg" alt="banner" class="trm-banner-cover" data-swiper-parallax-y="-200" data-swiper-parallax-scale="1.2"></div>
            <div class="swiper-slide"><img src="/img/blog/b3.jpg" alt="banner" class="trm-banner-cover" data-swiper-parallax-y="-200" data-swiper-parallax-scale="1.2"></div>
        </div>
    </div> -->
    <!-- banner slideshow cover end -->

    <!-- banner video cover -->
    <!-- <video autoplay="autoplay" loop muted playsinline webkit-playinginline class="trm-banner-cover" data-scroll data-scroll-direction="vertical" data-scroll-speed="-4">
        <source src="img/banner.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
        <source src="img/banner.webm" type='video/webm; codecs="vp8, vorbis"'>
        <source src="img/banner.ogg" type='video/ogg; codecs="theora, vorbis"'>
        Your browser does not support HTML5 video.
    </video> -->
    <!-- banner video cover end -->

    <!-- banner cover end -->

    <!-- banner content -->
    <div class="trm-banner-content trm-overlay">
        <div class="container" data-scroll data-scroll-direction="vertical" data-scroll-speed="0">
            <div class="row">
                <div class="col-lg-4"></div>
                <div class="col-lg-8">

                    <!-- banner title -->
                    <div class="trm-banner-text">
                        <div class="trm-label trm-mb-20">
                            NEWS LETTER
                        </div>
                        <h1 class="trm-mb-30 trm-hsmb-font">
                            C++笔记
                        </h1>

                        
                            <ul class="trm-breadcrumbs trm-label">
                                <li>
                                    <a href="/" class="trm-anima-link">Home</a>
                                </li>
                                <li>
                                    <span>
                                        2022
                                    </span
                                ></li>
                            </ul>
                        
                    </div>
                    <!-- banner title end -->

                    <!-- scroll hint -->
                    <a href="#about-triger" data-scroll-to="#about-triger" data-scroll-offset="-130" class="trm-scroll-hint-frame">
                        <div class="trm-scroll-hint"></div>
                        <span class="trm-label">Scroll down</span>
                    </a>
                    <!-- scroll hint end -->

                </div>
            </div>
        </div>
    </div>
    <!-- banner content end -->
</div>
    <!-- banner end -->

    <div class="container">
        <div class="row">
            <div class="col-lg-4">
                <!-- main card -->
                <div class="trm-main-card-frame trm-sidebar">
    <div class="trm-main-card" data-scroll data-scroll-repeat data-scroll-sticky data-scroll-target="#content" data-scroll-offset="60">
        <!-- card header -->
        <div class="trm-mc-header">
            <div class="trm-avatar-frame trm-mb-20"><img class="trm-avatar" src="/img/SuperMa.jpg" alt="Avatar"> </div>
            <h5 class="trm-name trm-mb-15">
                SuperMa
            </h5>
            <div class="trm-label">
                I`m
                <span class="trm-typed-text">
                    <!-- Words for theme.user.typedText -->
                </span>
            </div>
        </div>
        <!-- card header end -->
        <div class="trm-divider trm-mb-40 trm-mt-40"></div>
        <!-- sidebar social -->
        <div class="trm-social">
            
                <a href="https://github.com/RillMa/rillma.github.io" rel="nofollow" target="_blank">
                    <i class="fab fa-github"></i>
                </a>
            
                <a href="https://gitee.com" rel="nofollow" target="_blank">
                    <i class="iconfont cg-gitee"></i>
                </a>
            
                <a href="https://weibo.com/" rel="nofollow" target="_blank">
                    <i class="iconfont cg-weibo"></i>
                </a>
            
        </div>
        <!-- sidebar social end -->
        <div class="trm-divider trm-mb-40 trm-mt-40"></div>
        <!-- info -->
        <ul class="trm-table trm-mb-20">
            
                <li>
                    <div class="trm-label">
                        Residence:
                    </div>
                    <div class="trm-label trm-label-light">
                        HuBei
                    </div>
                </li>
            
                <li>
                    <div class="trm-label">
                        City:
                    </div>
                    <div class="trm-label trm-label-light">
                        YiChang
                    </div>
                </li>
            
                <li>
                    <div class="trm-label">
                        Age:
                    </div>
                    <div class="trm-label trm-label-light">
                        24
                    </div>
                </li>
            
        </ul>
        
        <!-- info end -->
        <div class="trm-divider trm-mb-40 trm-mt-40"></div>
        <!-- action button -->
        <div class="text-center">
            <a href="mailto:664468131@qq.com" class="trm-btn">
                Contact Me
                <i class="far fa-envelope"></i>
            </a>
        </div>
        <!-- action button end -->
        
    </div>
</div>
                <!-- main card end -->
            </div>
            <div class="col-lg-8">
                <!-- content -->
                <div class="trm-content" id="trm-content">
                    <div data-scroll data-scroll-repeat data-scroll-offset="500" id="about-triger"></div>
                    
                    <div class="row">
                        <div class="col-lg-4">
                            <div class="trm-card trm-label trm-label-light text-center"><i class="far fa-calendar-alt trm-icon"></i><br>
                                07/17
                            </div>
                        </div>
                        <div class="col-lg-4">
                            <div class="trm-card trm-label trm-label-light text-center"><i class="far fa-clock trm-icon"></i><br>
                                10:26
                            </div>
                        </div>
                        <div class="col-lg-4">
                            <div class="trm-card trm-label trm-label-light text-center"><i class="far fa-user trm-icon"></i><br>
                                SuperMa
                            </div>
                        </div>
                    </div>

                    <article class="trm-card trm-publication">
                        <h2 id="C-基础入门："><a href="#C-基础入门：" class="headerlink" title="C++基础入门："></a>C++基础入门：</h2><h3 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h3><h4 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h4><p><strong>指针的作用：</strong>可以通过指针间接访问内存</p>
<ul>
<li>内存编号是从0开始的，一般用十六进制数字表示</li>
<li>可以利用指针变量保存地址</li>
</ul>
<h4 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h4><p>指针变量定义语法： 数据类型 * 变量名;</p>
<h4 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h4><p>在32位操作系统下：占用4个字节空间，64位下占8个字节空间</p>
<p>7.4 空指针和野指针</p>
<p><strong>空指针：</strong>指针变量指向内存中编号为0的空间</p>
<p><strong>用图：</strong>初始化指针变量</p>
<p><strong>注意：</strong>空指针指向的内存是不可以访问的</p>
<h4 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h4><p>const修饰指针有三种情况：</p>
<p>1.const修饰指针 —— const int * p &#x3D; &amp;a; ——常量指针</p>
<p>2.const修饰常量 —— int * const p &#x3D; &amp;a; ——指针常量</p>
<p>3.const既修饰指针又修饰常量</p>
<h4 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h4><p><strong>作用：</strong>利用指针访问数组中元素</p>
<h4 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h4><p>作用：利用指针作函数参数，可以修改实参的值</p>
<h2 id="C-核心编程："><a href="#C-核心编程：" class="headerlink" title="C++核心编程："></a><strong>C++核心编程：</strong></h2><h3 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a><strong>1 内存分区模型</strong></h3><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>
<li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程</p>
<h4 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a><strong>1.1 程序运行前</strong></h4><p>在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p><strong>代码区：</strong></p>
<p>​	存放CPU执行的机器指令</p>
<p>​	代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>​    代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p><strong>全局区:</strong></p>
<p>​	全局变量和静态变量存放在此.</p>
<p>​	全局区还包含了常量区,字符串常量和其他常量也存放在此.</p>
<p>​	该区域的数据在程序结束后由操作系统释放.</p>
<p>总结：</p>
<ul>
<li><p>C++中在程序运行前分为全局区和代码区</p>
</li>
<li><p>代码区特点是共享和只读</p>
</li>
<li><p>全局区中存放全局变量、静态变量、常量</p>
</li>
<li><p>常量区中存放const修饰的全局常量和字符串常量</p>
</li>
</ul>
<h4 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a><strong>1.2 程序运行后</strong></h4><p><strong>栈区：</strong></p>
<p>​	注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 </p>
<p><strong>堆区：</strong></p>
<p>​	在C++中主要利用new在堆区开辟内存</p>
<h4 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a><strong>1.3 new操作符</strong></h4><p>​	C++中利用<strong>new</strong>操作符在堆区开辟数据，由程序员手动开辟和释放，释放操作符用<strong>delete</strong></p>
<h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h3><h4 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h4><p><strong>作用：</strong>给变量起别名</p>
<p><strong>语法：</strong>数据类型 &amp;别名 &#x3D; 原名</p>
<h4 id="2-2-引用的注意事项"><a href="#2-2-引用的注意事项" class="headerlink" title="2.2 引用的注意事项"></a>2.2 引用的注意事项</h4><p>​	引用必须初始化，初始化后不可以改变</p>
<h4 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h4><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<h4 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h4><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<h4 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h4><p>本质：<strong>引用的本质在C++内部实现是一个指针常量</strong></p>
<p>结论：C++推荐使用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h4 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h4><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加<strong>const修饰形参</strong>，防止形参改变实参</p>
<h3 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h3><h4 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h4><p>在C++中，函数的形参列表中的形参是可以有默认值的</p>
<p>语法：返回值类型 函数名 （参数 &#x3D; 默认值） { }</p>
<h4 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h4><p>C++中函数的形参列表中可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong>返回值类型 函数名 （数据类型）{}</p>
<h4 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h4><h5 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h5><p><strong>作用:</strong> 函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件:</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>或者<strong>个数不同</strong>或者<strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong> 函数的返回值不可以作为函数重载的条件</p>
<h5 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h5><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<h3 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a>4 类和对象</h3><p>C++面向对象的三大特性：<strong>封装，继承，多态</strong></p>
<h4 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h4><h5 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1 封装的意义"></a>4.1.1 封装的意义</h5><ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong>在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong>class 类名{访问权限： 属性 &#x2F; 行为}</p>
<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<p>1.public       公共权限</p>
<p>2.private      私有权限</p>
<p>3.protected 保护权限</p>
<p><strong>4.2.2 struct和class的区别</strong></p>
<p>唯一区别在于<strong>默认的访问权限不同</strong>：</p>
<ul>
<li>struct默认为公共的</li>
<li>class默认为私有的</li>
</ul>
<p><strong>4.2.3</strong> <strong>将成员属性设置为私有</strong></p>
<p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>
<h4 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h4><p>C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置。</p>
<h5 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h5><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​	一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>C++利用了<strong>构造函数和析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数:主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数:主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p>**构造函数语法: **类名(){}</p>
<p>1.构造函数，没有返回值也不写void</p>
<p>2.函数名称与类名相同</p>
<p>3.构造函数可以有参数，因此可以发生重载</p>
<p>4.程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次</p>
<p><strong>析构函数语法:</strong> ~类名(){}</p>
<p>1.析构函数，没有返回值也不写void</p>
<p>2.函数名称与类名相同，在名称前加上符号~</p>
<p>3.析构函数不可以有参数，因此不可以发生重载</p>
<p>4.程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</p>
<h5 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h5><p>两种分类方式：</p>
<p>​				按参数分为：有参构造和无参构造</p>
<p>​				按类型分为：普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​				括号法</p>
<p>​				显示法</p>
<p>​				隐式转换法</p>
<h5 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h5><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<h5 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h5><p>默认情况下，C++编译器至少给一个类添加3个函数</p>
<p>1.默认构造函数（无参，函数体为空）</p>
<p>2.默认析构函数（无参，函数体为空）</p>
<p>3.默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下:</p>
<ul>
<li>如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</li>
<li>如果用户定义拷贝构造函数，C++不会再提供其他构造函数</li>
</ul>
<h5 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h5><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作，带来的问题就是堆区的内存重复释放</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
<h5 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h5><p><strong>作用：</strong>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong>构造函数（）：属性1（值1），属性2（值2）…{}</p>
<h5 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h5><p>C++类中的成员可以是另一个类的对象，我们称该成员为对象成员</p>
<h5 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h5><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<p>1.静态成员变量：</p>
<ul>
<li>​	所有对象共享同一份数据</li>
<li>​	在编译阶段分配内存</li>
<li>​	类内声明，类外初始化</li>
</ul>
<p>2.静态成员函数：</p>
<ul>
<li>​	所有对象共享同一个函数</li>
<li>​	静态成员函数只能访问静态成员变量</li>
</ul>
<p>访问方式都有两种，通过对象和通过类名</p>
<h4 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h4><h5 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h5><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象</p>
<h5 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h5><p><strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<h5 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h5><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<h5 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h5><p>常函数：</p>
<ul>
<li>成员函数后加const后我们称这个函数为常函数</li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p>常对象：</p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<h4 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h4><p>友元的目的就是让一个函数或者类，访问另一个类中私有成员</p>
<p>友元的关键字为<strong>friend</strong></p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h4><p>概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h5 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h5><p>作用：实现两个自定义数据类型相加的运算</p>
<p>总结1：对于内置的数据类型的表达式的运算符是不可能改变的</p>
<p>总结2：不要滥用运算符重载</p>
<h5 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h5><p>作用：可以输出自定义数据类型</p>
<h5 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h5><p>作用：通过重载递增运算符，实现自己的整型数据</p>
<h5 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h5><p>C++编译器至少给一个类添加4个函数</p>
<p>1.默认构造函数（无参，函数体为空）</p>
<p>2.默认析构函数（无参，函数体为空）</p>
<p>3.默认拷贝构造函数，对属性进行值拷贝</p>
<p>4.赋值运算符operator&#x3D;，对属性值进行值拷贝</p>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<h5 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h5><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<h5 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h5><ul>
<li>函数调用运算符()也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<h4 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6 继承"></a>4.6 继承</h4><p><strong>继承是面向对象三大特性之一</strong></p>
<h5 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h5><p>继承的好处：<strong>减少重复代码</strong><br>基本语法：class 子类（派生类）：继承方式 父类（基类）</p>
<p><strong>派生类中的成员，包含两大部分：</strong></p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过来的表现其共性，而新增的成员体现了其个性。</p>
<h5 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h5><p>继承方式一共有三种：</p>
<ul>
<li><p>公共继承</p>
</li>
<li><p>保护继承</p>
</li>
<li><p>私有继承</p>
<p><img src="https://s2.loli.net/2022/07/17/1e3ITFftOgxUADk.png" alt="image-20220108161631398"></p>
</li>
</ul>
<h5 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h5><p>父类中所有非静态成员属性都会被子类继承下去<br>父类中私有成员属性 是被编译器给隐藏了，因此访问不到，但确实被继承下去了</p>
<p><strong>利用开发人员命令提示工具查看对象模型：</strong><br>跳转盘符 D:</p>
<p><img src="https://s2.loli.net/2022/07/17/RE342FXuC7bTWkK.png" alt="image-20220116190538707"></p>
<p>跳转文件路径 cd 具体路径下</p>
<p><img src="https://s2.loli.net/2022/07/17/OrFz3l9s5aSIJb7.png" alt="image-20220116190600852"></p>
<p>查看命名<br>cl &#x2F;d1 reportSingleClassLayout类名（比如Son） 文件名（比如按个03后按tab键）</p>
<p><img src="https://s2.loli.net/2022/07/17/QiJTex8hpRjyNHc.png" alt="image-20220116190637569"></p>
<h5 id="4-6-4-继承中构造和析构的顺序"><a href="#4-6-4-继承中构造和析构的顺序" class="headerlink" title="4.6.4 继承中构造和析构的顺序"></a>4.6.4 继承中构造和析构的顺序</h5><p>总结：继承中先调用父类构造函数，再调用子类构造函数，析构的顺序和构造的顺序相反</p>
<h5 id="4-6-5-继承中同名成员的处理方式"><a href="#4-6-5-继承中同名成员的处理方式" class="headerlink" title="4.6.5 继承中同名成员的处理方式"></a>4.6.5 继承中同名成员的处理方式</h5><ul>
<li><p>访问子类同名成员时，直接访问即可</p>
</li>
<li><p>访问父类同名成员时，需要加作用域</p>
</li>
</ul>
<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类和父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h5 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h5><p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员，直接访问即可</li>
<li>访问父类同名成员，需要加作用域</li>
</ul>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象和通过类名）</p>
<h5 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h5><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：class 子类 ：继承方式 父类1，继承方式 父类2…</p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<h5 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h5><p>概念：两个派生类继承同一个基类</p>
<p>又有某个类同时继承两个派生类</p>
<p>这种继承被称为菱形继承，或者钻石继承</p>
<p><img src="https://s2.loli.net/2022/07/17/2wGW5YNhBflzJ8D.png" alt="image-20220208155141443"></p>
<p>菱形继承问题：</p>
<p>1.羊继承了动物的数据，驼也继承了动物的数据，当羊驼使用数据时，就会产生二义性。</p>
<p>2.羊驼继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份即可。</p>
<p>总结：</p>
<ul>
<li>当菱形继承时，两个父类拥有同样的数据，需要用作用域加以区分；这份数据我们知道只需要一份，菱形继承导致有两份，造成资源浪费</li>
<li>利用虚继承，解决菱形继承中的问题，继承之前，加上关键字virtual变为虚继承</li>
</ul>
<h4 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7 多态"></a>4.7 多态</h4><h5 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h5><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态:函数重载和运算符重载属于静态多态，复用函数名</li>
<li>动态多态:派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别:</p>
<ul>
<li>静态多态的函数地址早绑定 – 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定 – 运行阶段确定函数地址</li>
</ul>
<p>总结：</p>
<p>多态满足条件：</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件：</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>
<h5 id="4-7-2-多态案例——计算器类"><a href="#4-7-2-多态案例——计算器类" class="headerlink" title="4.7.2 多态案例——计算器类"></a>4.7.2 多态案例——计算器类</h5><p>案例描述：分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
<h5 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h5><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法: virtual 返回值类型 函数名(参数列表) &#x3D; 0；</p>
<p>当类中有了纯虚函数，这个类也称为抽象类</p>
<p><strong>抽象类特点:</strong></p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<h5 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二 - 制作饮品"></a>4.7.4 多态案例二 - 制作饮品</h5><p><strong>案例描述:</strong><br>制作饮品的大致流程为：煮水-冲泡-倒入杯中-加入辅料<br>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><img src="https://s2.loli.net/2022/07/17/p3fmVGWCbOIdjRt.png" alt="image-20220225160247930"></p>
<h5 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h5><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p><strong>虚析构语法：</strong></p>
<p>virtual ~类名(){}</p>
<p><strong>纯虚析构语法：</strong></p>
<p>virtual ~类名() &#x3D; 0;</p>
<p>类名::~类名(){}</p>
<p><strong>总结：</strong></p>
<ol>
<li>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</li>
<li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</li>
<li>拥有纯虚析构函数的类也属于抽象类</li>
</ol>
<h3 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h3><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件<fstream></p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong> - 文件以文本的ASCII码形式存储在计算机中</li>
<li><strong>二进制文件</strong> - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类：</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream：读操作</li>
<li>fstream：读写操作</li>
</ol>
<h4 id="5-1-文本文件"><a href="#5-1-文本文件" class="headerlink" title="5.1 文本文件"></a>5.1 文本文件</h4><h5 id="5-1-1-写文件"><a href="#5-1-1-写文件" class="headerlink" title="5.1.1 写文件"></a>5.1.1 写文件</h5><p>写文件步骤如下：</p>
<p>1.包含头文件</p>
<p>#include <fstream></p>
<p>2.创建流对象</p>
<p>ofstream ofs;</p>
<p>3.打开文件</p>
<p>ofs.open(“文件路径”, 打开方式)</p>
<p>4.写数据</p>
<p>ofs &lt;&lt; “写入的数据”;</p>
<p>5.关闭文件</p>
<p>文件打开方式：</p>
<p><img src="https://s2.loli.net/2022/07/17/zDPbqWegKdTYjV1.png" alt="image-20220301160938934"></p>
<p><strong>注意：</strong>文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 ios::binary | ios::out  </p>
<h5 id="5-1-2-读文件"><a href="#5-1-2-读文件" class="headerlink" title="5.1.2 读文件"></a>5.1.2 读文件</h5><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：</p>
<p>1.包含头文件</p>
<p>​	#include <fstream></p>
<p>2.创建流对象</p>
<p>​	ifstream ifs;</p>
<p>3.打开文件并判断文件是否打开成功</p>
<p>​	ifs.open(“文件路径”, 打开方式);</p>
<p>4.读数据</p>
<p>​	四种方式读取</p>
<p>5.关闭文件</p>
<p>​	ifs.close();</p>
<h4 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h4><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为<strong>ios::binary</strong></p>
<h5 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h5><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型：ostream&amp; write(const char * buffer, int len);</p>
<p>参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数</p>
<h5 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h5><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：istream&amp; read(char *buffer, int len);</p>
<p>参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数</p>
<h2 id="C-提高编程"><a href="#C-提高编程" class="headerlink" title="C++提高编程"></a>C++提高编程</h2><h3 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h3><h4 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h4><p>模板就是建立通用的模具，大大提高复用性</p>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h4 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h4><ul>
<li>C++另一种编程思想成为泛型编程，主要利用的技术就是模板</li>
<li>C++提供两种模板机制：<strong>函数模板</strong>和<strong>类模板</strong></li>
</ul>
<h5 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h5><p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表</p>
<p><strong>语法：</strong></p>
<p>template<typename T></p>
<p>函数声明或定义</p>
<p><strong>解释：</strong></p>
<p>template —— 声明创建模板</p>
<p>typename —— 表明其后面的符号是一种数据类型，可以用class代替</p>
<p>T —— 通用的数据类型，名称可以替换，通常为大写字母</p>
<p>总结：</p>
<ul>
<li>函数模板利用关键字template</li>
<li>使用函数模板有两种方式：自动类型推导，显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h5 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h5><p>注意事项：</p>
<ul>
<li>自动类型推导，必须推导出一致的数据类型T，才可以使用</li>
<li>模板必须要确定出T的数据类型，才可以使用</li>
</ul>
<h5 id="1-2-3-普通函数和函数模板的区别"><a href="#1-2-3-普通函数和函数模板的区别" class="headerlink" title="1.2.3 普通函数和函数模板的区别"></a>1.2.3 普通函数和函数模板的区别</h5><ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<h5 id="1-2-4-普通函数和函数模板的调用规则"><a href="#1-2-4-普通函数和函数模板的调用规则" class="headerlink" title="1.2.4 普通函数和函数模板的调用规则"></a>1.2.4 普通函数和函数模板的调用规则</h5><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配，优先调用函数模板</li>
</ol>
<h5 id="1-2-5-模板的局限性"><a href="#1-2-5-模板的局限性" class="headerlink" title="1.2.5 模板的局限性"></a>1.2.5 模板的局限性</h5><p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h4 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h4><h5 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h5><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表</li>
</ul>
<p><strong>语法：</strong></p>
<p>template<class T></p>
<p>类</p>
<p><strong>解释：</strong></p>
<p>template —— 声明创建模板</p>
<p>class —— 表明其后面的符号是一种数据类型，可以用typename代替</p>
<p>T —— 通用的数据类型，名称可以替换，通常为大写字母</p>
<h5 id="1-3-2-类模板和函数模板的区别"><a href="#1-3-2-类模板和函数模板的区别" class="headerlink" title="1.3.2 类模板和函数模板的区别"></a>1.3.2 类模板和函数模板的区别</h5><p>类模板与函数模板区别主要有两点：</p>
<p>1.类模板没有自动类型推导的使用方式</p>
<p>2.类模板在模板参数列表中可以有默认参数</p>
<h5 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h5><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<h5 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h5><p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式：</p>
<p>1.指定传入的类型	——直接显示对象的数据类型</p>
<p>2.参数模板化			——将对象中的参数变为模板进行传递</p>
<p>3.整个类模板化		——将这个对象类型模板化进行传递</p>
<p>第一种比较常用</p>
<h5 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h5><p>当类模板碰到继承时，需要注意以下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指出父类中T的类型，子类也需要变为类模板</li>
</ul>
<h5 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h5><h5 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h5><p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li>
</ul>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含.cpp源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀为.hpp，hpp是约定的名称，并不是强制 (主流方式)</li>
</ul>
<h5 id="1-3-8-类模板和友元"><a href="#1-3-8-类模板和友元" class="headerlink" title="1.3.8 类模板和友元"></a>1.3.8 类模板和友元</h5><p>全局函数类内实现——直接在类内声明友元即可</p>
<p>全局函数类外实现——需要提前让编译器知道全局函数的存在</p>
<h3 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h3><h4 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h4><ul>
<li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p>
</li>
<li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p>
</li>
<li><p>大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</p>
</li>
<li><p>为了建立数据结构和算法的一套标准，诞生了<strong>STL</strong></p>
</li>
</ul>
<h4 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h4><ul>
<li>STL（Standard Template Library，标准模板库）</li>
<li>STL从广义上分为：<strong>容器（container） 算法（algorithm） 迭代器（iterator）</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接</li>
<li>STL几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h4 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h4><p>STL大体分为六大组件，分别是：<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<p>1.容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据</p>
<p>2.算法：各种常用的算法，如sort、find、copy、for_each等</p>
<p>3.迭代器：扮演了容器与算法之间的胶合剂</p>
<p>4.仿函数：行为类似函数，可作为算法的某种策略</p>
<p>5.适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</p>
<p>6.空间配置器：负责空间的配置与管理</p>
<h4 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4 STL中容器、算法、迭代器"></a>2.4 STL中容器、算法、迭代器</h4><p><strong>容器</strong>：置物之所也</p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组，链表，树，栈，队列，集合，映射表等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p>​							<strong>序列式容器</strong>：强调值的排序，序列式容器中的每个元素均有固定的位置。</p>
<p>​							<strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<p><strong>算法</strong>：问题之解法也</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p><strong>迭代器</strong>：容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、&#x3D;&#x3D;、！&#x3D;</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前向后操作</td>
<td>读写，支持++、–</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td>
</tr>
</tbody></table>
<p>常用的容器中迭代器种类为双向迭代器和随机访问迭代器</p>
<h4 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h4><p>STL中最常用的容器为vector，可以理解为数组</p>
<h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：vector</p>
<p>算法：for_each</p>
<p>迭代器：vector<int>::iterator</p>
<h4 id="2-5-2-vector存放自定义数据类型"><a href="#2-5-2-vector存放自定义数据类型" class="headerlink" title="2.5.2 vector存放自定义数据类型"></a>2.5.2 vector存放自定义数据类型</h4><p>vector中存放自定义数据类型，并打印输出</p>
<h4 id="2-5-3-vector容器嵌套容器"><a href="#2-5-3-vector容器嵌套容器" class="headerlink" title="2.5.3 vector容器嵌套容器"></a>2.5.3 vector容器嵌套容器</h4><h3 id="3-STL—常用容器"><a href="#3-STL—常用容器" class="headerlink" title="3 STL—常用容器"></a>3 STL—常用容器</h3><h4 id="3-1-string容器基本概念"><a href="#3-1-string容器基本概念" class="headerlink" title="3.1 string容器基本概念"></a>3.1 string容器基本概念</h4><h5 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h5><p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类</li>
</ul>
<p><strong>string和char*区别：</strong></p>
<ul>
<li>char*是一个指针</li>
<li>string是一个类，类内部封装了<strong>char</strong><em>，管理这个字符串，是一个char</em>型的容器</li>
</ul>
<p><strong>特点:</strong></p>
<p>string类内部封装了很多成员方法</p>
<p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h5 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h5><p>构造函数原型：</p>
<ul>
<li>string()；                              &#x2F;&#x2F;创建一个空的字符串例如: string str：</li>
<li>string(const char* s )；     &#x2F;&#x2F;使用字符串s初始化</li>
<li>string(const string&amp; str);   &#x2F;&#x2F;使用一个string对象初始化另一个string对象</li>
<li>string(int n, char c);            &#x2F;&#x2F;使用n个字符c初始化</li>
</ul>
<p>总结：string的多种构造方式没有可比性，灵活使用即可</p>
<h5 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h5><p>功能描述：</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型:</p>
<ul>
<li>string&amp; operator&#x3D;(const char* s );         &#x2F;&#x2F;char*类型字符串赋值给当前的字符串</li>
<li>string&amp; operator&#x3D;( const string &amp;s ) ;    &#x2F;&#x2F;把字符串s赋给当前的字符串</li>
<li>string&amp; operator&#x3D;(char c);                       &#x2F;&#x2F;字符赋值给当前的字符串</li>
<li>string&amp; assign(const char *s );                &#x2F;&#x2F;把字符串s赋给当前的字符串</li>
<li>string&amp; assign(const char *s， int n);    &#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串</li>
<li>string&amp; assign(const string &amp;s ) ;            &#x2F;&#x2F;把字符串s赋给当前字符串</li>
<li>string&amp; assign(int n, char c);                    &#x2F;&#x2F;用n个字符c赋给当前字符串</li>
</ul>
<h5 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h5><p>函数原型：</p>
<ul>
<li>string&amp; operator+&#x3D;( const char* str);                 &#x2F;&#x2F;重载+&#x3D;操作符</li>
<li>string&amp; operator+&#x3D;( const char c);                      &#x2F;&#x2F;重载+&#x3D;操作符</li>
<li>string&amp; operator+&#x3D;(const string&amp; str);               &#x2F;&#x2F;重载+&#x3D;操作符</li>
<li>string&amp; append(const char *s );                          &#x2F;&#x2F;把字符串s连接到当前字符串结尾</li>
<li>string&amp; append(const char *s, int n);                  &#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾</li>
<li>string&amp; append(const string &amp;s );                        &#x2F;&#x2F;同operator+&#x3D;(const string&amp; str)</li>
<li>string&amp; append(const string &amp;s,int pos,int n);    &#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<h5 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h5><p><strong>功能描述：</strong></p>
<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><img src="https://s2.loli.net/2022/07/17/xcpenUYFwAKVdyv.png" alt="image-20220323150631468"></p>
<p>总结：</p>
<ul>
<li>find查找是从左往右，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h5 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h5><p><strong>比较方式：</strong></p>
<ul>
<li>字符串比较是按字符串的ASCII码逐个进行对比</li>
</ul>
<p>&#x3D; 返回 0</p>
<p>＞返回1</p>
<p>＜返回-1</p>
<p><strong>函数原型：</strong></p>
<p><img src="https://s2.loli.net/2022/07/17/hdzxyqVKfb7TNYk.png" alt="image-20220323160119145"></p>
<h5 id="3-1-7-string字符串存取"><a href="#3-1-7-string字符串存取" class="headerlink" title="3.1.7 string字符串存取"></a>3.1.7 string字符串存取</h5><p>string中单个字符存取方式有两种</p>
<p><img src="https://s2.loli.net/2022/07/17/PVyxYrfgjTu4peU.png" alt="image-20220323162212287"></p>
<h5 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h5><p>函数原型：</p>
<p><img src="https://s2.loli.net/2022/07/17/by9tvjxJZk7DRaK.png" alt="image-20220323165409968"></p>
<h5 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h5><p>函数原型：</p>
<p><img src="https://s2.loli.net/2022/07/17/ake6qFhmVIBHOp5.png" alt="image-20220323171557362"></p>
<h4 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h4><h5 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h5><p><strong>功能：</strong></p>
<ul>
<li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector和普通数组的区别：</strong></p>
<ul>
<li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li>
</ul>
<p><strong>动态扩展：</strong></p>
<ul>
<li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/WfHOF6o2qpkAKyZ.png" alt="image-20220325143911475"></p>
<p>vector的大小有两个维度一个是size一个是capicity，size就是我们平时用来遍历vector时候用的，例如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; vec.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而capicity是vector底层数组（就是普通数组）的大小，capicity可不一定就是size。</p>
<p>当insert数据的时候，如果已经大于capicity，capicity会成倍扩容，但对外暴漏的size其实仅仅是+1。</p>
<p>那么既然vector底层实现是普通数组，怎么扩容的？</p>
<p>就是重新申请一个二倍于原数组大小的数组，然后把数据都拷贝过去，并释放原数组内存。（对，就是这么原始粗暴的方法！）</p>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h5 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h5><p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><img src="https://s2.loli.net/2022/07/17/ecxaE1LJ7SWPRrG.png" alt="image-20220325145501670"></p>
<h5 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h5><p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><img src="https://s2.loli.net/2022/07/17/vnFx4cBDH61RP37.png" alt="image-20220325161136785"></p>
<h5 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4 vector容量和大小"></a>3.2.4 vector容量和大小</h5><p><img src="https://s2.loli.net/2022/07/17/5V8v7eniHIotNP4.png" alt="image-20220330161845154"></p>
<h5 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h5><p><img src="https://s2.loli.net/2022/07/17/DtaBUyqZwTmo8vV.png" alt="image-20220330151446925"></p>
<h5 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h5><p><img src="https://s2.loli.net/2022/07/17/oMg5Z9drW1kjTyS.png" alt="image-20220330160857584"></p>
<h5 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h5><p>swap(vec); &#x2F;&#x2F;将vec与本身的元素互换</p>
<p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h5 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h5><p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>reserve(int len); &#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问</li>
</ul>
<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h4 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h4><h5 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h5><p>功能：双端数组，可以对头端进行插入删除操作</p>
<p><strong>deque和vector的区别：</strong></p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度比vector快</li>
<li>vector访问元素时的速度会比deque快，这和两者内部实现有关</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/4pqsKB9F86SLUrb.png" alt="image-20220404135349269"></p>
<h5 id="3-3-2-deque构造函数（与vector类似）"><a href="#3-3-2-deque构造函数（与vector类似）" class="headerlink" title="3.3.2 deque构造函数（与vector类似）"></a>3.3.2 deque构造函数（与vector类似）</h5><p><img src="https://s2.loli.net/2022/07/17/fTe5FKPHMtYAyRm.png" alt="image-20220404135505175"></p>
<h5 id="3-3-3-deque赋值操作（与vector类似）"><a href="#3-3-3-deque赋值操作（与vector类似）" class="headerlink" title="3.3.3 deque赋值操作（与vector类似）"></a>3.3.3 deque赋值操作（与vector类似）</h5><p><img src="https://s2.loli.net/2022/07/17/t4Is953pzJvf6we.png" alt="image-20220404135939618"></p>
<h5 id="3-3-4-deque大小操作（与vector相似，但deque没有容量的概念）"><a href="#3-3-4-deque大小操作（与vector相似，但deque没有容量的概念）" class="headerlink" title="3.3.4 deque大小操作（与vector相似，但deque没有容量的概念）"></a>3.3.4 deque大小操作（与vector相似，但deque没有容量的概念）</h5><p><img src="https://s2.loli.net/2022/07/17/GiodebNtTlWqXSH.png" alt="image-20220404140227809"></p>
<h5 id="3-3-5-deque插入和删除"><a href="#3-3-5-deque插入和删除" class="headerlink" title="3.3.5 deque插入和删除"></a>3.3.5 deque插入和删除</h5><p><img src="https://s2.loli.net/2022/07/17/kPNFZxVOeRKBiEn.png" alt="image-20220404150958649"></p>
<h5 id="3-3-6-deque数据存取（与vector相似）"><a href="#3-3-6-deque数据存取（与vector相似）" class="headerlink" title="3.3.6 deque数据存取（与vector相似）"></a>3.3.6 deque数据存取（与vector相似）</h5><p><img src="https://s2.loli.net/2022/07/17/bpYQN8RUM9iBhKL.png" alt="image-20220404155509604"></p>
<h5 id="3-3-7-deque排序操作"><a href="#3-3-7-deque排序操作" class="headerlink" title="3.3.7 deque排序操作"></a>3.3.7 deque排序操作</h5><p><strong>算法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort(iterator beg, iterator end) //对beg和end区间内元素进行排序</span><br></pre></td></tr></table></figure>

<p>默认从小到大排序<br>对于支持随机访问的迭代器的容器，都可以利用sort算法直接对其进行排序，vector也是</p>
<h4 id="3-4-stack容器"><a href="#3-4-stack容器" class="headerlink" title="3.4 stack容器"></a>3.4 stack容器</h4><h5 id="3-4-1-stack基本概念"><a href="#3-4-1-stack基本概念" class="headerlink" title="3.4.1 stack基本概念"></a>3.4.1 stack基本概念</h5><p>概念：stack是一种<strong>先进后出</strong>（First in Last Out, FILO）的数据结构，它只有一个出口</p>
<p><img src="https://s2.loli.net/2022/07/17/DVCOBewFqy42zAx.png" alt="image-20220404160743622"></p>
<p>栈中只有顶端的元素才可以被外界使用，因此<strong>栈不允许有遍历行为</strong></p>
<h5 id="3-4-2-stack常用接口"><a href="#3-4-2-stack常用接口" class="headerlink" title="3.4.2 stack常用接口"></a>3.4.2 stack常用接口</h5><p><img src="https://s2.loli.net/2022/07/17/LQy7aS46nTxk9i2.png" alt="image-20220404163322268"></p>
<h4 id="3-5-queue容器"><a href="#3-5-queue容器" class="headerlink" title="3.5 queue容器"></a>3.5 queue容器</h4><h5 id="3-5-1-queue基本概念"><a href="#3-5-1-queue基本概念" class="headerlink" title="3.5.1 queue基本概念"></a>3.5.1 queue基本概念</h5><p><strong>概念：</strong>queue是一种<strong>先进先出</strong>（First in First Out, FIFO）的数据结构，它有两个出口</p>
<p><img src="https://s2.loli.net/2022/07/17/YkypKHt5hlOdVAP.png" alt="image-20220404164959465"></p>
<p>队列容器允许从一端新增元素，从另一端移除元素</p>
<p>队列只有队头和队尾才可以被外界使用，因此<strong>队列不允许有遍历行为</strong></p>
<p>入队：push</p>
<p>出队：pop</p>
<h5 id="3-5-2-queue常用接口"><a href="#3-5-2-queue常用接口" class="headerlink" title="3.5.2 queue常用接口"></a>3.5.2 queue常用接口</h5><p><img src="https://s2.loli.net/2022/07/17/PzlBvAxwKSbYRpV.png" alt="image-20220407163110118"></p>
<h4 id="3-6-list容器"><a href="#3-6-list容器" class="headerlink" title="3.6 list容器"></a>3.6 list容器</h4><h5 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h5><p><strong>功能：</strong>将数据进行链式存储</p>
<p><strong>链表（list）</strong>是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成：链表由一系列<strong>结点</strong>组成</p>
<p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p>
<p>STL中的链表是一个双向循环链表（循环：头指针指向尾部，尾指针指向头部）</p>
<p> <img src="https://s2.loli.net/2022/07/17/vpIZiG5h2RPTdNc.png" alt="image-20220407174042719"></p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p>
<p><strong>优点：</strong></p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>空间（指针域）和时间（遍历）额外耗费较大</li>
</ul>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的</p>
<p>总结：</p>
<p>STL中<strong>List和vector是两个最常使用的容器</strong>，各有优缺点</p>
<h5 id="3-7-2-list构造函数（和其他几种一样）"><a href="#3-7-2-list构造函数（和其他几种一样）" class="headerlink" title="3.7.2 list构造函数（和其他几种一样）"></a>3.7.2 list构造函数（和其他几种一样）</h5><p><img src="https://s2.loli.net/2022/07/17/ml4epvCztnBHkI6.png" alt="image-20220412091557463"></p>
<h5 id="3-7-3-list赋值和交换"><a href="#3-7-3-list赋值和交换" class="headerlink" title="3.7.3 list赋值和交换"></a>3.7.3 list赋值和交换</h5><p><img src="https://s2.loli.net/2022/07/17/tUnv4POsW1A2dLz.png" alt="image-20220412092906501"></p>
<h5 id="3-7-4-list大小操作"><a href="#3-7-4-list大小操作" class="headerlink" title="3.7.4 list大小操作"></a>3.7.4 list大小操作</h5><p><img src="https://s2.loli.net/2022/07/17/6gSAt5w3v79Dy4C.png" alt="image-20220412093440155"></p>
<h5 id="3-7-5-list插入和删除"><a href="#3-7-5-list插入和删除" class="headerlink" title="3.7.5 list插入和删除"></a>3.7.5 list插入和删除</h5><p><img src="https://s2.loli.net/2022/07/17/FExo9rGTbzsjOKk.png" alt="image-20220412101517219"></p>
<h5 id="3-7-6-list数据存取"><a href="#3-7-6-list数据存取" class="headerlink" title="3.7.6 list数据存取"></a>3.7.6 list数据存取</h5><p><img src="https://s2.loli.net/2022/07/17/kAarfxG6M7sUXol.png" alt="image-20220412133406565"></p>
<p>list容器<strong>不可以通过[]和at方式访问数据</strong>，原因是list本质链表，不是用连续线性空间存储数据，迭代器也是<strong>不支持随机访问</strong>的</p>
<h5 id="3-7-7-list反转和排序"><a href="#3-7-7-list反转和排序" class="headerlink" title="3.7.7 list反转和排序"></a>3.7.7 list反转和排序</h5><p><img src="https://s2.loli.net/2022/07/17/hLdBROafsxSCT78.png" alt="image-20220412134757944"></p>
<h4 id="3-7-set-x2F-multiset容器"><a href="#3-7-set-x2F-multiset容器" class="headerlink" title="3.7 set&#x2F;multiset容器"></a>3.7 set&#x2F;multiset容器</h4><h5 id="3-7-1-set基本概念"><a href="#3-7-1-set基本概念" class="headerlink" title="3.7.1 set基本概念"></a>3.7.1 set基本概念</h5><p><strong>简介：</strong></p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>set&#x2F;multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现的</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>set不允许容器中有重复元素</li>
<li>multiset允许容器中有重复元素</li>
</ul>
<h5 id="3-7-2-set构造和赋值"><a href="#3-7-2-set构造和赋值" class="headerlink" title="3.7.2 set构造和赋值"></a>3.7.2 set构造和赋值</h5><p> <img src="https://s2.loli.net/2022/07/17/pBbYixHgvNeQL7M.png" alt="image-20220415090939342"></p>
<h5 id="3-7-3-set大小和交换"><a href="#3-7-3-set大小和交换" class="headerlink" title="3.7.3 set大小和交换"></a>3.7.3 set大小和交换</h5><p><img src="https://s2.loli.net/2022/07/17/fJFpCTUvsqN61V4.png" alt="image-20220415092109162"></p>
<h5 id="3-7-4-set插入和删除"><a href="#3-7-4-set插入和删除" class="headerlink" title="3.7.4 set插入和删除"></a>3.7.4 set插入和删除</h5><p><img src="https://s2.loli.net/2022/07/17/LWcAP5R3mBMhITt.png" alt="image-20220415092428456"></p>
<h5 id="3-7-5-set查找和统计"><a href="#3-7-5-set查找和统计" class="headerlink" title="3.7.5 set查找和统计"></a>3.7.5 set查找和统计</h5><p> <img src="https://s2.loli.net/2022/07/17/Yvhb4ePCy9MWxgf.png" alt="image-20220415092757268"></p>
<h5 id="3-7-6-set和multiset区别"><a href="#3-7-6-set和multiset区别" class="headerlink" title="3.7.6 set和multiset区别"></a>3.7.6 set和multiset区别</h5><p><img src="https://s2.loli.net/2022/07/17/IXZtzC1xkVY4fSe.png" alt="image-20220415093702080"></p>
<h5 id="3-7-7-pair对组创建"><a href="#3-7-7-pair对组创建" class="headerlink" title="3.7.7 pair对组创建"></a>3.7.7 pair对组创建</h5><p><strong>功能描述：</strong></p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/SfJnRNCTqXua4Zh.png" alt="image-20220415100436474"></p>
<h5 id="3-7-8-set容器排序"><a href="#3-7-8-set容器排序" class="headerlink" title="3.7.8 set容器排序"></a>3.7.8 set容器排序</h5><p>学习目标：</p>
<ul>
<li>set容器默认排序规则为升序，掌握如何改变排序规则</li>
</ul>
<p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<h4 id="3-8-map-x2F-multimap容器"><a href="#3-8-map-x2F-multimap容器" class="headerlink" title="3.8 map&#x2F;multimap容器"></a>3.8 map&#x2F;multimap容器</h4><h5 id="3-8-1-map基本概念"><a href="#3-8-1-map基本概念" class="headerlink" title="3.8.1 map基本概念"></a>3.8.1 map基本概念</h5><p><strong>简介：</strong></p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>map&#x2F;multimap属于关联式容器，底层结构是用二叉树实现</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p><strong>map和multimap的区别：</strong></p>
<ul>
<li>map不允许容器中有重复key值，而multimap可以</li>
</ul>
<h5 id="3-8-2-map构造和赋值"><a href="#3-8-2-map构造和赋值" class="headerlink" title="3.8.2 map构造和赋值"></a>3.8.2 map构造和赋值</h5><p><img src="https://s2.loli.net/2022/07/17/rXVgHQ8MS1mLqnA.png" alt="image-20220421102721023"></p>
<h5 id="3-8-3-map大小和交换"><a href="#3-8-3-map大小和交换" class="headerlink" title="3.8.3 map大小和交换"></a>3.8.3 map大小和交换</h5><p><img src="https://s2.loli.net/2022/07/17/Mu3gF8zx4jGpVCU.png" alt="image-20220421105052340"></p>
<h5 id="3-8-4-map插入和删除"><a href="#3-8-4-map插入和删除" class="headerlink" title="3.8.4 map插入和删除"></a>3.8.4 map插入和删除</h5><p><img src="https://s2.loli.net/2022/07/17/lG7cmuJKOSrEUhz.png" alt="image-20220421110619108"></p>
<h5 id="3-8-5-map查找和统计"><a href="#3-8-5-map查找和统计" class="headerlink" title="3.8.5 map查找和统计"></a>3.8.5 map查找和统计</h5><p><img src="https://s2.loli.net/2022/07/17/yesJTVOQdZUwDE3.png" alt="image-20220421131100043"></p>
<h5 id="3-8-6-map容器排序"><a href="#3-8-6-map容器排序" class="headerlink" title="3.8.6 map容器排序"></a>3.8.6 map容器排序</h5><ul>
<li>map默认排序是按照key值从小到大排序，还可以利用仿函数，改变排序规则，同set容器</li>
</ul>
<h3 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL-函数对象"></a>4 STL-函数对象</h3><h4 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h4><h5 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h5><p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li>
</ul>
<p><strong>本质：</strong></p>
<p>函数对象（仿函数）是一个类，不是一个函数</p>
<h5 id="4-1-2-函数对象调用"><a href="#4-1-2-函数对象调用" class="headerlink" title="4.1.2 函数对象调用"></a>4.1.2 函数对象调用</h5><p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<h4 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2 谓词"></a>4.2 谓词</h4><h5 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h5><ul>
<li>返回bool类型的仿函数称为谓词</li>
<li>如果operator()接受一个参数，就叫一元谓词</li>
<li>如果operator()接受两个参数，就叫二元谓词</li>
</ul>
<h4 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h4><h5 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h5><p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p><strong>分类：</strong></p>
<ul>
<li>算术仿函数</li>
<li>关系仿函数</li>
<li>逻辑仿函数</li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 #include <functional></li>
</ul>
<h5 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h5><p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
</ul>
<p>其中negate是一元运算，其他都是二元运算</p>
<p><img src="https://s2.loli.net/2022/07/17/ZeOTW4R9psvYizS.png" alt="image-20220427131128955"></p>
<h5 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h5><p><img src="https://s2.loli.net/2022/07/17/IWgL8KFl4A31e7k.png" alt="image-20220427133921403"></p>
<h5 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h5><p><img src="https://s2.loli.net/2022/07/17/FtWMqlNo4GzyQIn.png" alt="image-20220430112340042"></p>
<h3 id="5-STL—常用算法"><a href="#5-STL—常用算法" class="headerlink" title="5 STL—常用算法"></a>5 STL—常用算法</h3><p>概述：</p>
<p>算法主要是由头文件<algorithm> <functional> <numeric>组成</p>
<p><algorithm>是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等</p>
<p><numeric>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p>
<p><functional>定义了一些模板类，用以声明函数对象</p>
<h4 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h4><p><img src="https://s2.loli.net/2022/07/17/kEAyuYacWQTRxXq.png" alt="image-20220430114529652"></p>
<h5 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h5><p><img src="https://s2.loli.net/2022/07/17/U9tKsb8O6vHefh4.png" alt="image-20220502091332507"></p>
<h5 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h5><p> <strong>功能描述：</strong></p>
<p>搬运容器到另一个容器中</p>
<p><img src="https://s2.loli.net/2022/07/17/RSh1OWl5NdKoIcn.png" alt="image-20220502093505132"></p>
<h4 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h4><p><img src="https://s2.loli.net/2022/07/17/I59GeZgFBl3ObSq.png" alt="image-20220502094939190"></p>
<h5 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h5><p><strong>功能描述：</strong></p>
<p>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器</p>
<p><img src="https://s2.loli.net/2022/07/17/WUK2DutxNSvYl5f.png" alt="image-20220502095245571"></p>
<h5 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h5><p><img src="https://s2.loli.net/2022/07/17/X9E2GLCwdAWaQij.png" alt="image-20220504083522025"></p>
<h5 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h5><p><strong>功能描述：</strong></p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/cGP8lXmx3SjNH1t.png" alt="image-20220504091348370"></p>
<h5 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h5><p><img src="https://s2.loli.net/2022/07/17/XzYBtDk4IhZmfEb.png" alt="image-20220504091852376"></p>
<h5 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h5><p><img src="https://s2.loli.net/2022/07/17/hEezI9bYTxG4qJy.png" alt="image-20220504092437716"></p>
<p><strong>总结：</strong>统计自定义数据类型的时候，需要配合重载operator&#x3D;&#x3D;</p>
<h5 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h5><p> <img src="https://s2.loli.net/2022/07/17/hscHpqbNidgT1MD.png" alt="image-20220504093330554"></p>
<h4 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h4><p><img src="https://s2.loli.net/2022/07/17/gfsZ1mPiHhYB3Ia.png" alt="image-20220504100308242"></p>
<h5 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h5><p><img src="https://s2.loli.net/2022/07/17/iPOxBrKkbwgCTaX.png" alt="image-20220504100434058"></p>
<h5 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h5><p><strong>功能描述：</strong></p>
<ul>
<li>洗牌 指定范围内的元素随机调整次序</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/7ZERmzO8w4Jhucj.png" alt="image-20220504101813043"></p>
<p><strong>总结：</strong>使用时记得加随机数种子 srand((unsigned int)time(NULL))</p>
<h5 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h5><p><strong>功能描述：</strong></p>
<ul>
<li>两个容器元素合并，并存储到另一容器中</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/17/UcYh2geqzGCmDaS.png" alt="image-20220504101945511"></p>
<h5 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h5><p><img src="https://s2.loli.net/2022/07/17/ixTFQgLUqDkydSn.png" alt="image-20220504105535969"></p>
<h4 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h4><p><img src="https://s2.loli.net/2022/07/17/ayA3YEIHLWifsoZ.png" alt="image-20220506085447171"></p>
<h5 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h5><p><img src="https://s2.loli.net/2022/07/17/T4Abq1UyXRj5hDV.png" alt="image-20220506085523034"></p>
<h5 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h5><p><img src="https://s2.loli.net/2022/07/17/T4Abq1UyXRj5hDV.png"></p>
<h5 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h5><p>  <img src="https://s2.loli.net/2022/07/17/oUEuiLa5V7P8eBQ.png" alt="image-20220506090100107"></p>
<h5 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h5><p><img src="https://s2.loli.net/2022/07/17/7LRSWcY62gCUpkh.png" alt="image-20220506090618418"></p>
<h4 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h4><p><strong>注意：</strong></p>
<p>算术生成算法属于小型算法，使用时包含的头文件为**#include<numeric>**</p>
<p><strong>算法简介：</strong></p>
<ul>
<li>accumulate    &#x2F;&#x2F;计算容器元素累计总和</li>
<li>fill                    &#x2F;&#x2F;向容器中添加元素</li>
</ul>
<h5 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h5><p><img src="https://s2.loli.net/2022/07/17/OtyoQeTmEq3Mr6f.png" alt="image-20220506092024208"></p>
<p>value为起始累加值，一般为0</p>
<h5 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h5><p><img src="https://s2.loli.net/2022/07/17/VItxi5ypQUomb4g.png" alt="image-20220506092808727"></p>
<h4 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h4><p><img src="https://s2.loli.net/2022/07/17/FSKe3mYcf6QPLiR.png" alt="image-20220506095303461"></p>
<h5 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h5><p><img src="https://s2.loli.net/2022/07/17/6FyU3R51NgZxluK.png" alt="image-20220506102502318"></p>
<p><strong>总结：</strong></p>
<ul>
<li>求交集的两个集合必须为有序序列</li>
<li>目标容器开辟空间需要从两个容器中取最小值</li>
<li>set_intersection返回值即是交集中最后一个元素的位置</li>
</ul>
<h5 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h5><p><img src="https://s2.loli.net/2022/07/17/Nu1LIqbjETfgF4O.png" alt="image-20220506105042572"></p>
<p><strong>总结：</strong></p>
<ul>
<li>求并集的两个集合必须为有序序列</li>
<li>目标容器开辟空间需要两个容器相加</li>
<li>set_union返回值即是交集中最后一个元素的位置</li>
</ul>
<h5 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3 set_difference"></a>5.6.3 set_difference</h5><p><img src="https://s2.loli.net/2022/07/17/tPpk8nHyuVlDO5q.png" alt="image-20220506112448473"></p>
<p><strong>总结：</strong></p>
<ul>
<li>求差集的两个集合必须为有序序列</li>
<li>目标容器开辟空间需要从两个容器取较大值</li>
<li>set_union返回值即是差集中最后一个元素的位置</li>
</ul>
<h2 id="STL标准库和泛型编程"><a href="#STL标准库和泛型编程" class="headerlink" title="STL标准库和泛型编程"></a>STL标准库和泛型编程</h2><h3 id="1-STL体系结构基础（p2）"><a href="#1-STL体系结构基础（p2）" class="headerlink" title="1.STL体系结构基础（p2）"></a>1.STL体系结构基础（p2）</h3><p><img src="https://s2.loli.net/2022/07/17/foWdAn17UHZ6Twj.png" alt="image-20220717232011912"></p>
<h3 id="2-OOP-vs-GP-面向对象编程vs泛型编程-p9"><a href="#2-OOP-vs-GP-面向对象编程vs泛型编程-p9" class="headerlink" title="2.OOP vs. GP(面向对象编程vs泛型编程 p9)"></a>2.OOP vs. GP(面向对象编程vs泛型编程 p9)</h3><p><img src="https://s2.loli.net/2022/07/17/Cg5Zc3iyNUn6Fmx.png" alt="image-20220717232042185"></p>
<p><img src="https://s2.loli.net/2022/07/17/Cg5Zc3iyNUn6Fmx.png"></p>
<p>以上部分知识来源于：</p>
<ul>
<li>B站视频《黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难》：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1et411b73Z?from=search&seid=838229607464854275&vd_source=b1c88616f60be0f2efeb0a475e10cf74">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难_哔哩哔哩_bilibili</a></li>
<li>侯捷老师视频之《STL标准库和泛型编程》</li>
</ul>

                    </article>

                    <!-- blog -->
                    <div class="row">
                        <div class="col-lg-12">
                            <!-- title -->
                            <h5 class="trm-mb-40 trm-title-with-divider">
                                Other Articles
                                <span data-number="02"></span>
                            </h5>
                        </div>
                        
                            <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation" data-scroll data-scroll-offset="40">
        <a href="/2022/07/26/%E9%98%BF%E9%87%8C%E4%BA%91%E9%AA%8C%E8%AF%81%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5/" class="trm-cover-frame trm-anima-link">
            <img src="/img/AliyunPic.jpeg" alt="cover">
        </a>
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" /categories/Record/">
                    Record
                </a>
            </div>
            <h5>
                <a href="/2022/07/26/%E9%98%BF%E9%87%8C%E4%BA%91%E9%AA%8C%E8%AF%81%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5/" class="trm-anima-link">
                    阿里云验证上传图片失败
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>
                    07/26
                </li>
                <li>
                    12:33
                </li>
                <li>
                    475
                </li>
            </ul>
        </div>
    </div>
</div>
                        
                        
                            <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation" data-scroll data-scroll-offset="40">
        <a href="/2022/06/19/hello-world/" class="trm-cover-frame trm-anima-link">
            <img src="/img/HelloWorld.jpeg" alt="cover">
        </a>
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" #.">
                    unclassified
                </a>
            </div>
            <h5>
                <a href="/2022/06/19/hello-world/" class="trm-anima-link">
                    Hello World
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>
                    06/19
                </li>
                <li>
                    05:28
                </li>
                <li>
                    75
                </li>
            </ul>
        </div>
    </div>
</div>
                        
                    </div>
                    <!-- blog end -->

                    

                    <div class="trm-divider trm-mb-40"></div>

                    <!-- footer -->
                    <footer class="trm-scroll-animation" data-scroll data-scroll-offset="50">
    <div class="trm-label">
        ©  2022- 2022 ·
        <span class="trm-accent-color">
            SuperMa
        </span>
    </div>
    <div class="trm-label">
        The blog has been lovely to run:
        <span id="since" class="trm-accent-color"></span>
        day
    </div>
</footer>
<script>
    function show_date_time () {
        BirthDay = new Date("06/19/2022 17:30:00");
        today = new Date();
        timeold = (today.getTime() - BirthDay.getTime());
        msPerDay = 24 * 60 * 60 * 1000
        day = Math.floor(timeold / msPerDay)
        since.innerHTML = day
    }
    show_date_time()
</script>
                    <!-- footer end -->
                </div>
                <!-- content end -->
            </div>
        </div>
    </div>
</div>


    
  
  
            <!-- body end -->
          </div>
        </div>
      </div>
      <!-- scroll container end -->

      <!-- mode switcher -->
      <div class="trm-hidden-switcher">
        <div class="trm-mode-switcher"><i class="far fa-sun"></i>
          <input class="tgl tgl-light" id="trm-swich" type="checkbox">
          <label class="trm-swich" for="trm-swich"></label>
          <i class="far fa-moon"></i>
        </div>
      </div>
      <!-- mode switcher end -->

  </div>
  <!-- app wrapper end -->

  
<script src="/js/plugins/jquery.min.js"></script>
<script src="/js/plugins/swup.min.js"></script>
<script src="/js/plugins/locomotive-scroll.js"></script>
<script src="/js/plugins/typing.js"></script>
<script src="/js/plugins/fancybox.min.js"></script>
<script src="/js/plugins/swiper.min.js"></script>


<!-- 评论插件 -->


<!-- Service Worker -->


<script src="/js/main.js?v=1.0.2"></script>


</body>

</html>